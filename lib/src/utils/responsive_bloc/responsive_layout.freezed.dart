// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'responsive_layout.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ScreenType {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sm,
    required TResult Function() md,
    required TResult Function() lg,
    required TResult Function() xl,
    required TResult Function() xxl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sm,
    TResult? Function()? md,
    TResult? Function()? lg,
    TResult? Function()? xl,
    TResult? Function()? xxl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sm,
    TResult Function()? md,
    TResult Function()? lg,
    TResult Function()? xl,
    TResult Function()? xxl,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SM value) sm,
    required TResult Function(MD value) md,
    required TResult Function(LG value) lg,
    required TResult Function(XL value) xl,
    required TResult Function(XXL value) xxl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SM value)? sm,
    TResult? Function(MD value)? md,
    TResult? Function(LG value)? lg,
    TResult? Function(XL value)? xl,
    TResult? Function(XXL value)? xxl,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SM value)? sm,
    TResult Function(MD value)? md,
    TResult Function(LG value)? lg,
    TResult Function(XL value)? xl,
    TResult Function(XXL value)? xxl,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ScreenTypeCopyWith<$Res> {
  factory $ScreenTypeCopyWith(
          ScreenType value, $Res Function(ScreenType) then) =
      _$ScreenTypeCopyWithImpl<$Res, ScreenType>;
}

/// @nodoc
class _$ScreenTypeCopyWithImpl<$Res, $Val extends ScreenType>
    implements $ScreenTypeCopyWith<$Res> {
  _$ScreenTypeCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$SMCopyWith<$Res> {
  factory _$$SMCopyWith(_$SM value, $Res Function(_$SM) then) =
      __$$SMCopyWithImpl<$Res>;
}

/// @nodoc
class __$$SMCopyWithImpl<$Res> extends _$ScreenTypeCopyWithImpl<$Res, _$SM>
    implements _$$SMCopyWith<$Res> {
  __$$SMCopyWithImpl(_$SM _value, $Res Function(_$SM) _then)
      : super(_value, _then);
}

/// @nodoc

class _$SM implements SM {
  const _$SM();

  @override
  String toString() {
    return 'ScreenType.sm()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$SM);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sm,
    required TResult Function() md,
    required TResult Function() lg,
    required TResult Function() xl,
    required TResult Function() xxl,
  }) {
    return sm();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sm,
    TResult? Function()? md,
    TResult? Function()? lg,
    TResult? Function()? xl,
    TResult? Function()? xxl,
  }) {
    return sm?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sm,
    TResult Function()? md,
    TResult Function()? lg,
    TResult Function()? xl,
    TResult Function()? xxl,
    required TResult orElse(),
  }) {
    if (sm != null) {
      return sm();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SM value) sm,
    required TResult Function(MD value) md,
    required TResult Function(LG value) lg,
    required TResult Function(XL value) xl,
    required TResult Function(XXL value) xxl,
  }) {
    return sm(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SM value)? sm,
    TResult? Function(MD value)? md,
    TResult? Function(LG value)? lg,
    TResult? Function(XL value)? xl,
    TResult? Function(XXL value)? xxl,
  }) {
    return sm?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SM value)? sm,
    TResult Function(MD value)? md,
    TResult Function(LG value)? lg,
    TResult Function(XL value)? xl,
    TResult Function(XXL value)? xxl,
    required TResult orElse(),
  }) {
    if (sm != null) {
      return sm(this);
    }
    return orElse();
  }
}

abstract class SM implements ScreenType {
  const factory SM() = _$SM;
}

/// @nodoc
abstract class _$$MDCopyWith<$Res> {
  factory _$$MDCopyWith(_$MD value, $Res Function(_$MD) then) =
      __$$MDCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MDCopyWithImpl<$Res> extends _$ScreenTypeCopyWithImpl<$Res, _$MD>
    implements _$$MDCopyWith<$Res> {
  __$$MDCopyWithImpl(_$MD _value, $Res Function(_$MD) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MD implements MD {
  const _$MD();

  @override
  String toString() {
    return 'ScreenType.md()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MD);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sm,
    required TResult Function() md,
    required TResult Function() lg,
    required TResult Function() xl,
    required TResult Function() xxl,
  }) {
    return md();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sm,
    TResult? Function()? md,
    TResult? Function()? lg,
    TResult? Function()? xl,
    TResult? Function()? xxl,
  }) {
    return md?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sm,
    TResult Function()? md,
    TResult Function()? lg,
    TResult Function()? xl,
    TResult Function()? xxl,
    required TResult orElse(),
  }) {
    if (md != null) {
      return md();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SM value) sm,
    required TResult Function(MD value) md,
    required TResult Function(LG value) lg,
    required TResult Function(XL value) xl,
    required TResult Function(XXL value) xxl,
  }) {
    return md(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SM value)? sm,
    TResult? Function(MD value)? md,
    TResult? Function(LG value)? lg,
    TResult? Function(XL value)? xl,
    TResult? Function(XXL value)? xxl,
  }) {
    return md?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SM value)? sm,
    TResult Function(MD value)? md,
    TResult Function(LG value)? lg,
    TResult Function(XL value)? xl,
    TResult Function(XXL value)? xxl,
    required TResult orElse(),
  }) {
    if (md != null) {
      return md(this);
    }
    return orElse();
  }
}

abstract class MD implements ScreenType {
  const factory MD() = _$MD;
}

/// @nodoc
abstract class _$$LGCopyWith<$Res> {
  factory _$$LGCopyWith(_$LG value, $Res Function(_$LG) then) =
      __$$LGCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LGCopyWithImpl<$Res> extends _$ScreenTypeCopyWithImpl<$Res, _$LG>
    implements _$$LGCopyWith<$Res> {
  __$$LGCopyWithImpl(_$LG _value, $Res Function(_$LG) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LG implements LG {
  const _$LG();

  @override
  String toString() {
    return 'ScreenType.lg()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LG);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sm,
    required TResult Function() md,
    required TResult Function() lg,
    required TResult Function() xl,
    required TResult Function() xxl,
  }) {
    return lg();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sm,
    TResult? Function()? md,
    TResult? Function()? lg,
    TResult? Function()? xl,
    TResult? Function()? xxl,
  }) {
    return lg?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sm,
    TResult Function()? md,
    TResult Function()? lg,
    TResult Function()? xl,
    TResult Function()? xxl,
    required TResult orElse(),
  }) {
    if (lg != null) {
      return lg();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SM value) sm,
    required TResult Function(MD value) md,
    required TResult Function(LG value) lg,
    required TResult Function(XL value) xl,
    required TResult Function(XXL value) xxl,
  }) {
    return lg(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SM value)? sm,
    TResult? Function(MD value)? md,
    TResult? Function(LG value)? lg,
    TResult? Function(XL value)? xl,
    TResult? Function(XXL value)? xxl,
  }) {
    return lg?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SM value)? sm,
    TResult Function(MD value)? md,
    TResult Function(LG value)? lg,
    TResult Function(XL value)? xl,
    TResult Function(XXL value)? xxl,
    required TResult orElse(),
  }) {
    if (lg != null) {
      return lg(this);
    }
    return orElse();
  }
}

abstract class LG implements ScreenType {
  const factory LG() = _$LG;
}

/// @nodoc
abstract class _$$XLCopyWith<$Res> {
  factory _$$XLCopyWith(_$XL value, $Res Function(_$XL) then) =
      __$$XLCopyWithImpl<$Res>;
}

/// @nodoc
class __$$XLCopyWithImpl<$Res> extends _$ScreenTypeCopyWithImpl<$Res, _$XL>
    implements _$$XLCopyWith<$Res> {
  __$$XLCopyWithImpl(_$XL _value, $Res Function(_$XL) _then)
      : super(_value, _then);
}

/// @nodoc

class _$XL implements XL {
  const _$XL();

  @override
  String toString() {
    return 'ScreenType.xl()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$XL);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sm,
    required TResult Function() md,
    required TResult Function() lg,
    required TResult Function() xl,
    required TResult Function() xxl,
  }) {
    return xl();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sm,
    TResult? Function()? md,
    TResult? Function()? lg,
    TResult? Function()? xl,
    TResult? Function()? xxl,
  }) {
    return xl?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sm,
    TResult Function()? md,
    TResult Function()? lg,
    TResult Function()? xl,
    TResult Function()? xxl,
    required TResult orElse(),
  }) {
    if (xl != null) {
      return xl();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SM value) sm,
    required TResult Function(MD value) md,
    required TResult Function(LG value) lg,
    required TResult Function(XL value) xl,
    required TResult Function(XXL value) xxl,
  }) {
    return xl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SM value)? sm,
    TResult? Function(MD value)? md,
    TResult? Function(LG value)? lg,
    TResult? Function(XL value)? xl,
    TResult? Function(XXL value)? xxl,
  }) {
    return xl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SM value)? sm,
    TResult Function(MD value)? md,
    TResult Function(LG value)? lg,
    TResult Function(XL value)? xl,
    TResult Function(XXL value)? xxl,
    required TResult orElse(),
  }) {
    if (xl != null) {
      return xl(this);
    }
    return orElse();
  }
}

abstract class XL implements ScreenType {
  const factory XL() = _$XL;
}

/// @nodoc
abstract class _$$XXLCopyWith<$Res> {
  factory _$$XXLCopyWith(_$XXL value, $Res Function(_$XXL) then) =
      __$$XXLCopyWithImpl<$Res>;
}

/// @nodoc
class __$$XXLCopyWithImpl<$Res> extends _$ScreenTypeCopyWithImpl<$Res, _$XXL>
    implements _$$XXLCopyWith<$Res> {
  __$$XXLCopyWithImpl(_$XXL _value, $Res Function(_$XXL) _then)
      : super(_value, _then);
}

/// @nodoc

class _$XXL implements XXL {
  const _$XXL();

  @override
  String toString() {
    return 'ScreenType.xxl()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$XXL);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() sm,
    required TResult Function() md,
    required TResult Function() lg,
    required TResult Function() xl,
    required TResult Function() xxl,
  }) {
    return xxl();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? sm,
    TResult? Function()? md,
    TResult? Function()? lg,
    TResult? Function()? xl,
    TResult? Function()? xxl,
  }) {
    return xxl?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? sm,
    TResult Function()? md,
    TResult Function()? lg,
    TResult Function()? xl,
    TResult Function()? xxl,
    required TResult orElse(),
  }) {
    if (xxl != null) {
      return xxl();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SM value) sm,
    required TResult Function(MD value) md,
    required TResult Function(LG value) lg,
    required TResult Function(XL value) xl,
    required TResult Function(XXL value) xxl,
  }) {
    return xxl(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SM value)? sm,
    TResult? Function(MD value)? md,
    TResult? Function(LG value)? lg,
    TResult? Function(XL value)? xl,
    TResult? Function(XXL value)? xxl,
  }) {
    return xxl?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SM value)? sm,
    TResult Function(MD value)? md,
    TResult Function(LG value)? lg,
    TResult Function(XL value)? xl,
    TResult Function(XXL value)? xxl,
    required TResult orElse(),
  }) {
    if (xxl != null) {
      return xxl(this);
    }
    return orElse();
  }
}

abstract class XXL implements ScreenType {
  const factory XXL() = _$XXL;
}
